{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef } from 'react';\nimport { voiceService } from '../api/voiceService';\nexport const useVoiceRecording = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const mediaRecorder = useRef(null);\n  const audioChunks = useRef([]);\n  const silenceTimer = useRef(null);\n  const lastAudioTime = useRef(Date.now());\n  const startRecording = () => {\n    return new Promise(async resolve => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        mediaRecorder.current = new MediaRecorder(stream);\n        audioChunks.current = [];\n        mediaRecorder.current.ondataavailable = event => {\n          if (event.data.size > 0) {\n            audioChunks.current.push(event.data);\n            lastAudioTime.current = Date.now(); // 오디오 데이터 수신 시간 갱신\n          }\n        };\n        mediaRecorder.current.start(100); // 100ms 간격으로 데이터 수집\n        setIsRecording(true);\n        resolve();\n      } catch (error) {\n        console.error('Recording failed:', error);\n        resolve();\n      }\n    });\n  };\n  const stopRecording = () => {\n    return new Promise(resolve => {\n      if (mediaRecorder.current && isRecording) {\n        mediaRecorder.current.onstop = () => {\n          const audioBlob = new Blob(audioChunks.current, {\n            type: 'audio/webm'\n          });\n          setIsRecording(false);\n          mediaRecorder.current.stream.getTracks().forEach(track => track.stop());\n          resolve(audioBlob);\n        };\n        mediaRecorder.current.stop();\n      } else {\n        resolve(null);\n      }\n    });\n  };\n  const checkSilence = (callback, silenceThreshold = 5000) => {\n    if (silenceTimer.current) clearInterval(silenceTimer.current);\n    silenceTimer.current = setInterval(() => {\n      const timeSinceLastAudio = Date.now() - lastAudioTime.current;\n      if (timeSinceLastAudio >= silenceThreshold) {\n        stopRecording().then(callback);\n        clearInterval(silenceTimer.current);\n      }\n    }, 1000);\n  };\n  return {\n    isRecording,\n    startRecording,\n    stopRecording,\n    checkSilence\n  };\n};\n_s(useVoiceRecording, \"ANB5jYNlt41s7i3s3eJLWwMl6Mc=\");","map":{"version":3,"names":["useState","useRef","voiceService","useVoiceRecording","_s","isRecording","setIsRecording","mediaRecorder","audioChunks","silenceTimer","lastAudioTime","Date","now","startRecording","Promise","resolve","stream","navigator","mediaDevices","getUserMedia","audio","current","MediaRecorder","ondataavailable","event","data","size","push","start","error","console","stopRecording","onstop","audioBlob","Blob","type","getTracks","forEach","track","stop","checkSilence","callback","silenceThreshold","clearInterval","setInterval","timeSinceLastAudio","then"],"sources":["D:/dev/finalproj/react_finalproj/client/src/hooks/useVoiceRecording.js"],"sourcesContent":["import { useState, useRef } from 'react';\r\nimport { voiceService } from '../api/voiceService';\r\n\r\nexport const useVoiceRecording = () => {\r\n    const [isRecording, setIsRecording] = useState(false);\r\n    const mediaRecorder = useRef(null);\r\n    const audioChunks = useRef([]);\r\n    const silenceTimer = useRef(null);\r\n    const lastAudioTime = useRef(Date.now());\r\n\r\n    const startRecording = () => {\r\n        return new Promise(async (resolve) => {\r\n            try {\r\n                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n                mediaRecorder.current = new MediaRecorder(stream);\r\n                audioChunks.current = [];\r\n\r\n                mediaRecorder.current.ondataavailable = (event) => {\r\n                    if (event.data.size > 0) {\r\n                        audioChunks.current.push(event.data);\r\n                        lastAudioTime.current = Date.now(); // 오디오 데이터 수신 시간 갱신\r\n                    }\r\n                };\r\n\r\n                mediaRecorder.current.start(100); // 100ms 간격으로 데이터 수집\r\n                setIsRecording(true);\r\n                resolve();\r\n            } catch (error) {\r\n                console.error('Recording failed:', error);\r\n                resolve();\r\n            }\r\n        });\r\n    };\r\n\r\n    const stopRecording = () => {\r\n        return new Promise((resolve) => {\r\n            if (mediaRecorder.current && isRecording) {\r\n                mediaRecorder.current.onstop = () => {\r\n                    const audioBlob = new Blob(audioChunks.current, { type: 'audio/webm' });\r\n                    setIsRecording(false);\r\n                    mediaRecorder.current.stream.getTracks().forEach(track => track.stop());\r\n                    resolve(audioBlob);\r\n                };\r\n                mediaRecorder.current.stop();\r\n            } else {\r\n                resolve(null);\r\n            }\r\n        });\r\n    };\r\n\r\n    const checkSilence = (callback, silenceThreshold = 5000) => {\r\n        if (silenceTimer.current) clearInterval(silenceTimer.current);\r\n        \r\n        silenceTimer.current = setInterval(() => {\r\n            const timeSinceLastAudio = Date.now() - lastAudioTime.current;\r\n            if (timeSinceLastAudio >= silenceThreshold) {\r\n                stopRecording().then(callback);\r\n                clearInterval(silenceTimer.current);\r\n            }\r\n        }, 1000);\r\n    };\r\n\r\n    return {\r\n        isRecording,\r\n        startRecording,\r\n        stopRecording,\r\n        checkSilence\r\n    };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}